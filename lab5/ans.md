
## 1. Stack и Queue

#### Сложности операций Stack:

| Операция | Сложность |
|----------|-----------|
| `push()` | **O(1)** |
| `top()`  | **O(1)** |
| `pop()`  | **O(1)** |
| `size()` | **O(1)** |
| `empty()` | **O(1)** |

- `push()`: добавление в конец vector — одна операция записи в память (амортизированная O(1) из-за редких реаллокаций)
- `top()`: прямой доступ к последнему элементу по индексу data[size-1] — одно обращение к памяти
- `pop()`: уменьшение счётчика размера без сдвига элементов — одна операция
- `size()`: возврат хранимой переменной _size — одна операция
- `empty()`: сравнение `size == 0` — одна операция

---

#### Сложности операций Queue:

| Операция | Сложность |
|----------|-----------|
| `push()` | **O(1)** |
| `front()` | **O(1)** |
| `back()` | **O(1)** |
| `pop()` | **O(1)** |
| `size()` | **O(1)** |
| `empty()` | **O(1)** |

- `push()`: добавление в конец последнего блока deque — одна операция записи
- `front()`: прямой доступ по хранимому указателю на первый элемент — одно обращение к памяти
- `back()`: прямой доступ по хранимому указателю на последний элемент — одно обращение к памяти
- `pop()`: сдвиг указателя front_ptr на следующий элемент без перемещения данных — одна операция (в отличие от vector, где удаление первого элемента требует O(n) сдвига)
- `size()`: возврат хранимой переменной — одна операция
- `empty()`: сравнение size == 0 — одна операция

---

## 2. map, unordered_map

`map` хранит пары ключ-значение в **отсортированном** порядке.

```cpp
#include <map>

std::map<int, std::string> m;

m[42] = "answer";           // Вставка/изменение по ключу
m.insert({10, "ten"});      // Вставка пары
m.find(42);                 // Поиск по ключу (возвращает итератор)
m.erase(42);                // Удаление по ключу
m.size();                   // Размер
m.count(42);                // Проверка наличия ключа (0 или 1)
```

#### Сложности операций map:

| Операция | Сложность |
|----------|-----------|
| `operator[]` / `at()` | **O(log n)** |
| `insert()` | **O(log n)** |
| `find()` | **O(log n)** |
| `erase()` | **O(log n)** |
| `size()` | **O(1)** |
| `count()` | **O(log n)** |

- Элементы **всегда упорядочены** по ключу
- Итерация в **отсортированном** порядке
- Предсказуемая производительность O(log n)
❌ Медленнее, чем `unordered_map`
❌ Требует оператор сравнения для ключа (`<`)

---

### **unordered_map - хеш-таблица**

`unordered_map` хранит пары ключ-значение в **неупорядоченном** виде.

```cpp
#include <unordered_map>

std::unordered_map<int, std::string> um;

um[42] = "answer";          // Вставка/изменение по ключу
um.insert({10, "ten"});     // Вставка пары
um.find(42);                // Поиск по ключу
um.erase(42);               // Удаление по ключу
um.size();                  // Размер
um.count(42);               // Проверка наличия ключа
```

#### Сложности операций unordered_map:

| Операция | Средний случай | Худший случай |
|----------|----------------|---------------|
| `operator[]` / `at()` | **O(1)** | **O(n)** |
| `insert()` | **O(1)** | **O(n)** |
| `find()` | **O(1)** | **O(n)** |
| `erase()` | **O(1)** | **O(n)** |
| `size()` | **O(1)** | **O(1)** |
| `count()` | **O(1)** | **O(n)** |

> **Худший случай O(n)** возникает при коллизиях хеш-функции.

#### Особенности unordered_map:

- **Быстрее** для большинства операций (O(1) vs O(log n))
- Подходит когда порядок не важен
❌ Элементы **НЕ упорядочены**
❌ Требует **хеш-функцию** для ключа
❌ Худший случай O(n) при коллизиях

---
